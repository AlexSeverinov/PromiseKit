{"name":"Promisekit","tagline":"A delightful Promises implementation for iOS","body":"PromiseKit aims to make dealing with asynchronicity in your iPhone app *delightful*. PromiseKit is not just a Promises implementation, it is also a collection of helper functions that make the typical asyncronous patterns we use in iOS development *delightful* too.\r\n\r\nModern development is highly asynchronous: isn’t it about time we had tools that made programming asynchronously powerful, easy and delightful?\r\n\r\n\r\n#What is a Promise?\r\n\r\nA promise is an intent to accomplish an asyncronous task. Eg. some library promises to download a [gravatar](http://gravatar.com):\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (void)gravatar {\r\n    Promise *promise = [ABCDoEverythingLibrary gravatarURLForEmail:self.email];\r\n\r\n    promise.then(^(UIImage *img){\r\n        self.imageView.image = img;\r\n    }).fail(^(NSError *error){\r\n        NSLog(@\"%@\", error);\r\n    })\r\n}\r\n```\r\n\r\nA key feature of promises is that they are *thennable*.\r\n\r\nAnother key feature is that they are *chainable*.\r\n\r\nThe designer changes their mind (again). They want us to overlay a kitten on the gravatar:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (void)gravatar {\r\n    UIImage *gravatarImage = nil;\r\n\r\n    [ABCDoEverythingLibrary gravatarURLForEmail:self.email].then(^(UIImage *img){\r\n        gravatarImage = img;\r\n    }).fail(^(NSError *error){\r\n        NSLog(@\"%@\", error);\r\n    }).then(^{\r\n        return [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\r\n    }).then(^(UIImage *kittenImage){\r\n        self.imageView.image = [UIImage draw:kittenImage over:gravatarImage];\r\n    });\r\n}\r\n```\r\n\r\nWhoops! We aren’t handling the potential `NSURLConnection` error. Errors bubble up to the next fail handler, but they won't go backwards.\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (void)gravatar {\r\n    UIImage *gravatarImage = nil;\r\n\r\n    [ABCDoEverythingLibrary gravatarURLForEmail:self.email].then(^(UIImage *img){\r\n        gravatarImage = img;\r\n    }).then(^{\r\n        return [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\r\n    }).then(^(UIImage *kittenImage){\r\n        self.imageView.image = [UIImage draw:kittenImage over:gravatarImage];\r\n    }).fail(^(NSError *error){\r\n        // moved to the end: any errors or thrown exceptions will bubble up\r\n        NSLog(@\"%@\", error);\r\n    });\r\n}\r\n```\r\n\r\nNotably exceptions are caught and bubbled up also.\r\n\r\nLater we decide to refactor this code so our `imageView` is set elsewhere:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (Promise *)gravatar {\r\n    UIImage *gravatarImage = nil;\r\n\r\n    return [ABCDoEverythingLibrary gravatarURLForEmail:self.email].then(^(UIImage *img){\r\n        gravatarImage = img;\r\n    }).then(^{\r\n        return [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\r\n    }).then(^(UIImage *kittenImage){\r\n        return [UIImage draw:kittenImage over:gravatarImage];\r\n    });\r\n}\r\n\r\n- (void)viewDidLoad {\r\n    self.gravatar.then(^(UIImage *img){\r\n        self.imageView.image = img;\r\n    }).fail(^(NSError *error){\r\n        //TODO UIAlertView\r\n    });\r\n}\r\n```\r\n\r\nIn production we find that `ABCDoEverythingLibrary` is a buggy, bloated mostrosity. So we hastily reinvent the wheel:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (Promise *)gravatar {\r\n    UIImage *gravatarImage = nil;\r\n\r\n    return [Promise md5:self.email].then(^(NSString *md5){\r\n        // The MD5 is crunched in a background GCD queue\r\n        return [NSURLConnection GET:@\"http://gravatar.com/avatar/%@\", md5];\r\n    }).then(^{\r\n        return [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\r\n    }).then(^(UIImage *kittenImage){\r\n        return [UIImage draw:kittenImage over:gravatarImage];\r\n    });\r\n}\r\n```\r\n\r\nLater we realize we’re wasting our users’ lives by downloading the two images\r\nconsequentively:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (Promise *)gravatar {\r\n    UIImage *gravatarImage = nil;\r\n\r\n    return [Promise md5:self.email].then(^(NSString *md5){\r\n        id a = [NSURLConnection GET:@\"http://gravatar.com/avatar/%@\", md5];\r\n        id b = [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\r\n        return [Promise when:@[a, b]];\r\n    }).then(^(NSArray *images){\r\n        return [UIImage draw:images[0] over:images[1]];\r\n    });\r\n}\r\n```\r\n\r\nWe realize we need to preload the next gravatar when `viewWillAppear` is called (or after) but the first gravatar must have loaded first:\r\n\r\n```objc\r\n- (void)viewDidLoad {\r\n    self.gravatar.then(^(UIImage *img){\r\n        self.imageView.image = img;\r\n    }).fail(^(NSError *error){\r\n        //TODO UIAlertView\r\n    });\r\n}\r\n\r\n- (void)viewWillAppear:(BOOL)animated {\r\n    self.gravatar.then(^{\r\n        [self fetchNextGravatar];\r\n    });\r\n}\r\n```\r\n\r\nThis is a key concept in Promises. If the asynchronous task has finished, or is pending, it doesn't matter, we can still chain other tasks onto that Promise and know they will be handled either now or later, and in our chosen order.\r\n\r\n## The Niceties\r\n\r\nWe provide some convenience methods on `NSURLConnection` that return promises:\r\n\r\n```objc\r\n+ (Promise *)GET:(id)stringFormatOrURL, ...\r\n+ (Promise *)promise:(NSURLRequest *)request;\r\n\r\n// et cetera\r\n```\r\n\r\nWe also detect if the content-type is JSON or an image and process the data into a `UIImage`, etc. in a background thread.\r\n\r\nWe provide a promise for `CLLocationManager`:\r\n\r\n```objc\r\n[CLLocationManager promise].then(^(CLLocation *location){\r\n    // woot\r\n});\r\n```\r\n\r\nWe provide a promise structure for modally presenting `UIViewController`s:\r\n\r\n```objc\r\n\r\n@implementation MyRootViewController\r\n\r\n- (void)foo {\r\n    [self promiseViewController:[MyDetailViewController new] animated:YES completion:nil];\r\n}\r\n\r\n@end\r\n\r\n\r\n@implementation MyDetailViewController\r\n\r\n- (void)viewWillDefer:(Deferred *)deferred {\r\n    // save this and resolve/reject it when you are done\r\n    _deferred = deferred;\r\n}\r\n\r\n- (void)onCompletedWhatever {\r\n    [_deferred resolve:self.textField.text];  // dismisses the viewController\r\n}\r\n\r\n@end\r\n```\r\n\r\n\r\n# Deferred\r\n\r\nYou won’t use PromiseKit for long before you need to make your own promises. As per other Promise implementations we use the Deferred pattern. Create a deferred and return its promise to the caller. Then `resolve` or `reject` the deferred according to the result of your asyncronous operation.\r\n\r\n```objc\r\n- (Promise *)randomNumbers {\r\n    Deferred *deferred = [Deferred new];\r\n    [self.operationQueue addOperationWithBlock:^{\r\n        NSMutableArray *numbers = [NSMutableArray new];\r\n        for (int x = 0; x < 1000; x++)\r\n            [numbers addObject:@(arc4random())];\r\n        [deferred resolve:numbers];\r\n    }];\r\n    return deferred.promise;\r\n}\r\n```\r\n\r\n\r\n# Important Details Regarding “Promises”\r\n\r\n1. A promise moves from its `pending` state to either `resolved` or `rejected` *exactly **once***.\r\n2. A resolved or rejected promise that is `then`’d or `fail`’d executes the newly provided block immediately with its already `resolved` or `rejected` value.\r\n3. Errors bubble upwards to the first available fail handler, then stop bubbling. Then handlers do not bubble. This is so fail handlers behave more like `@try` and `@catch`.\r\n\r\n\r\n\r\n# But! This isn’t Promises/A/B/D/KISS…\r\n\r\nThe Promises specification is a bit of a mess. As is the nature of new programming patterns, we learn best practices as we go. I've used a bunch of Promises implementations across different platforms, and have now written a few too. My experience leads me to `then` being the success handler and `fail` the fail handler with an additional handler for the *both* case (here currently `yolo`).\r\n\r\nWe have no progress handler, because Cocoa now has `NSProgress`… so use that.\r\n\r\n\r\n# Alternatives\r\n\r\nPromiseKit is more or less unique, but the idea of *Promises* is not, and thus there are other projects to look at:\r\n\r\n1. Most famously is [Bolts](https://github.com/BoltsFramework/Bolts-iOS). I explored using this before making PromiseKit. I found that it didn’t make my code nicer than just implementing my own state machine.\r\n2. [RXPromise](https://github.com/couchdeveloper/RXPromise) is a nice Promises implementation without any of the convenience nicities that PromiseKit provides and with the somewhat irritating condition that `then` is by default executed in a background GCD queue.\r\n3. https://github.com/joshdholtz/ios-promises\r\n4. https://github.com/mproberts/objc-promise\r\n\r\nIMO you get the cleanest, most readable code with PromiseKit. And PromiseKit actually goes that step further and gives you tools that make using Promises with the iOS SDK *delightful*.\r\n\r\n\r\n# Caveats\r\n\r\n* With Objective-C we are used to explicit types, Promises turn everything into `id`. This can be a little unnerving, but in reality is less problematic than you might expect. After all, all other common modern languages are like this.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}