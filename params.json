{"name":"Promisekit","tagline":"A delightful Promises implementation for iOS","body":"PromiseKit aims to make dealing with asynchronicity in your iPhone app *delightful*. PromiseKit is not just a Promises implementation, it is also a collection of helper functions that make the typical asyncronous patterns we use in iOS development *delightful* too.\r\n\r\n\r\n#What is a Promise?\r\n\r\nA promise is an intent to accomplish an asyncronous task. Eg. some library promises to download a [gravatar](http://gravatar.com):\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (void)gravatar {\r\n    Promise *promise = [ABCDoEverythingLibrary gravatar:self.email];\r\n\r\n    promise.then(^(UIImage *img){\r\n        self.imageView.image = img;\r\n    }).fail(^(NSError *error){\r\n        NSLog(@\"%@\", error);\r\n    })\r\n}\r\n```\r\n\r\nA key feature of promises is that they are *thennable*.\r\n\r\nAnother key feature is that they are *chainable*.\r\n\r\nThe designer changes their mind (again). They want us to overlay a kitten on the gravatar:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (void)gravatar {\r\n    UIImage *gravatarImage = nil;\r\n\r\n    [ABCDoEverythingLibrary gravatar:self.email].then(^(UIImage *img){\r\n        gravatarImage = img;\r\n    }).fail(^(NSError *error){\r\n        NSLog(@\"%@\", error);\r\n    }).then(^{\r\n        return [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\r\n    }).then(^(UIImage *kittenImage){\r\n        self.imageView.image = [UIImage draw:kittenImage over:gravatarImage];\r\n    });\r\n}\r\n```\r\n\r\nWhoops! We aren’t handling the potential `NSURLConnection` error:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (void)gravatar {\r\n    UIImage *gravatarImage = nil;\r\n\r\n    [ABCDoEverythingLibrary gravatar:self.email].then(^(UIImage *img){\r\n        gravatarImage = img;\r\n    }).then(^{\r\n        return [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\r\n    }).then(^(UIImage *kittenImage){\r\n        self.imageView.image = [UIImage draw:kittenImage over:gravatarImage];\r\n    }).fail(^(NSError *error){\r\n        // moved to the end: any errors or thrown exceptions will bubble up\r\n        NSLog(@\"%@\", error);\r\n    });\r\n}\r\n```\r\n\r\nErrors bubble *up* to the nearest fail handler. Notably exceptions are caught and bubbled up also.\r\n\r\nWe need to refactor this code so our `imageView` is set elsewhere:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (Promise *)gravatar {\r\n    UIImage *gravatarImage = nil;\r\n\r\n    return [ABCDoEverythingLibrary gravatar:self.email].then(^(UIImage *img){\r\n        gravatarImage = img;\r\n    }).then(^{\r\n        return [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\r\n    }).then(^(UIImage *kittenImage){\r\n        return [UIImage draw:kittenImage over:gravatarImage];\r\n    });\r\n}\r\n\r\n- (void)viewDidLoad {\r\n    self.gravatar.then(^(UIImage *img){\r\n        self.imageView.image = img;\r\n    }).fail(^(NSError *error){\r\n        //TODO UIAlertView\r\n    });\r\n}\r\n```\r\n\r\nIn production we find that `ABCDoEverythingLibrary` is a buggy, bloated mostrosity. So we hastily reinvent the wheel:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (Promise *)gravatar {\r\n    UIImage *gravatarImage = nil;\r\n\r\n    return [Promise md5:self.email].then(^(NSString *md5){\r\n        // The MD5 is crunched in a background GCD queue\r\n        return [NSURLConnection GET:@\"http://gravatar.com/avatar/%@\", md5];\r\n    }).then(^{\r\n        return [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\r\n    }).then(^(UIImage *kittenImage){\r\n        return [UIImage draw:kittenImage over:gravatarImage];\r\n    });\r\n}\r\n```\r\n\r\nLater we realize we’re wasting our users’ lives by downloading the two images\r\nconsequentively:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (Promise *)gravatar {\r\n    UIImage *gravatarImage = nil;\r\n\r\n    return [Promise md5:self.email].then(^(NSString *md5){\r\n        id a = [NSURLConnection GET:@\"http://gravatar.com/avatar/%@\", md5];\r\n        id b = [NSURLConnection GET:@\"http://placekitten.com/100/100\"];\r\n        return [Promise when:@[a, b]];\r\n    }).then(^(NSArray *images){\r\n        return [UIImage draw:images[0] over:images[1]];\r\n    });\r\n}\r\n```\r\n\r\n\r\n## The Niceties\r\n\r\nWe provide some convenience methods on `NSURLConnection` that return promises:\r\n\r\n```objc\r\n+ (Promise *)GET:(id)stringFormatOrURL, ...\r\n+ (Promise *)send:(NSURLRequest *)request;\r\n\r\n// et cetera\r\n```\r\n\r\nWe also detect if the content-type is JSON or an image and process the data into a `UIImage`, etc. in a background thread.\r\n\r\nWe provide a promise for `CLLocationManager`:\r\n\r\n```objc\r\n[CLLocationManager promise].then(^(CLLocation *location){\r\n    // woot\r\n});\r\n```\r\n\r\nWe provide a promise structure for modally presenting `UIViewController`s:\r\n\r\n```objc\r\n\r\n@implementation MyRootViewController\r\n\r\n- (void)foo {\r\n    [self promiseViewController:myDetailViewController animated:YES completion:nil];\r\n}\r\n\r\n@end\r\n\r\n\r\n@implementation MyDetailViewController\r\n\r\n- (void)viewWillDefer:(Deferred *)deferred {\r\n    // save this and resolve/reject it when you are done\r\n    _deferred = deferred;\r\n}\r\n\r\n- (void)onCompletedWhatever {\r\n    [_deferred resolve:self.textField.text];  // dismisses the viewController\r\n}\r\n\r\n@end\r\n```\r\n\r\n\r\n# Deferred\r\n\r\nYou won’t use PromiseKit for long before you need to make your own promises. As per other Promise implementations we use the Deferred pattern. Create a deferred and return its promise to the caller. Then `resolve` or `reject` the deferred according to the result of your asyncronous operation.\r\n\r\n```objc\r\n- (Promise *)randomNumbers {\r\n    Deferred *deferred = [Deferred new];\r\n    [self.operationQueue addOperationWithBlock:^{\r\n        NSMutableArray *numbers = [NSMutableArray new];\r\n        for (int x = 0; x < 1000; x++)\r\n            [numbers addObject:@(arc4random())];\r\n        [deferred resolve:numbers];\r\n    }];\r\n    return deferred.promise;\r\n}\r\n```\r\n\r\n\r\n# Important Details Regarding “Promises”\r\n\r\n1. A promise moves from its `unfulfilled` state to either `resolved` or `rejected` *exactly **once***.\r\n2. A resolved or rejected promise that is then’d or fail’d returns its already computed result.\r\n3. Errors bubble upwards to the first available fail handler\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}