{"name":"Promisekit","tagline":"A delightful Promises implementation for iOS","body":"Modern development is highly asyncronous; isn’t it about time iOS developers had tools that made programming asyncronously powerful, easy and delightful?\r\n\r\nPromiseKit is not just a Promises implementation, it is also a collection of helper functions that make the typical asyncronous patterns we use in iOS development *delightful* too.\r\n\r\n\r\n#Using PromiseKit\r\n\r\nIn your [Podfile](http://guides.cocoapods.org/syntax/podfile.html):\r\n\r\n```ruby\r\npod 'PromiseKit'\r\n```\r\n\r\n\r\n#What is a Promise?\r\n\r\nSynchronous code is clean code:\r\n\r\n```objc\r\n- (void)setGravatarForEmail:(NSString *)email {\r\n    NSString *md5 = md5(email);\r\n    NSString *url = [@\"http://gravatar.com/avatar/%@\" stringByAppendingString:md5];\r\n    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:url]];\r\n    self.imageView.image = [UIImage imageWithData:data];\r\n}\r\n```\r\n\r\nClean but blocking: the UI lags: the user rates you one star.\r\n\r\nThe asyncronous analog suffers from “rightward-drift”:\r\n\r\n\r\n```objc\r\n- (void)setGravatarForEmail:(NSString *)email {\r\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\r\n        NSString *md5 = md5(email);\r\n        NSString *url = [@\"http://gravatar.com/avatar/%@\" stringByAppendingString:md5];\r\n        NSURLRequest *rq = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];\r\n        [NSURLConnection sendAsyncronousRequest:rq queue:[NSOperationQueue currentQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {\r\n            UIImage *gravatarImage = [UIImage imageWithData:data];\r\n            dispatch_async(dispatch_get_main_queue(), ^{\r\n                self.imageView.image = gravatarImage;\r\n            });\r\n        }];\r\n    });\r\n}\r\n```\r\n\r\nThe code that does the actual work is now buried inside asyncronicity boilerplate. It is harder to read. The code is less clean.\r\n\r\nA promise is an intent to accomplish an asyncronous task:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (void)setGravatarForEmail:(NSString *)email {\r\n    [Promise md5:email].then(^(NSString *md5){\r\n        return [NSURLConnection GET:@\"http://gravatar.com/avatar/%@\", md5];\r\n    }).then(^(UIImage *gravatarImage){\r\n        self.imageView.image = gravatarImage;\r\n    });\r\n}\r\n```\r\n\r\n\r\n#Error Handling\r\n\r\nSynchronous code allows us to use exceptions:\r\n\r\n```objc\r\n- (void)setGravatarForEmail:(NSString *)email {\r\n    @try {\r\n        NSString *md5 = md5(email);\r\n        NSString *url = [@\"http://gravatar.com/avatar/%@\" stringByAppendingString:md5];\r\n        NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:url]];\r\n        self.imageView.image = [UIImage imageWithData:data];\r\n    } @catch (NSError *error) {\r\n        //TODO\r\n    }\r\n}\r\n```\r\n\r\nError handling with asyncronous code is notoriously tricky:\r\n\r\n```objc\r\n- (void)setGravatarForEmail:(NSString *)email {\r\n    void (^errorHandler)(NSError *) = ^(NSError *error){\r\n        //TODO\r\n    };\r\n\r\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\r\n        @try {\r\n            NSString *md5 = md5(email);\r\n            NSString *url = [@\"http://gravatar.com/avatar/%@\" stringByAppendingString:md5];\r\n            NSURLRequest *rq = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];\r\n            [NSURLConnection sendAsyncronousRequest:rq queue:[NSOperationQueue currentQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {\r\n\r\n                // the code is now misleading since exceptions thrown in this\r\n                // block will not bubble up to our @catch\r\n\r\n                if (connectionError) {\r\n                    errorHandler(connectionError);\r\n                } else {\r\n                    UIImage *img = [UIImage imageWithData:data];\r\n                    dispatch_async(dispatch_get_main_queue(), ^{\r\n                        self.imageView.image = img;\r\n                    });\r\n                }\r\n            }];\r\n        } @catch (NSError *err) {\r\n            errorHandler(err);\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nYuck! Hideous! And *even more* rightward-drift.\r\n\r\nPromises have elegant error handling:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\n- (void)setGravatarForEmail:(NSString *)email {\r\n    [Promise md5:email].then(^(NSString *md5){\r\n        return [NSURLConnection GET:@\"http://gravatar.com/avatar/%@\", md5];\r\n    }).then(^(UIImage *gravatarImage){\r\n        self.imageView.image = gravatarImage;\r\n    }).catch(^(NSError *error){\r\n        //TODO\r\n    });\r\n}\r\n```\r\n\r\nErrors bubble up to the first `catch` handler in the chain.\r\n\r\n\r\n#Asyncronous State Machines\r\n\r\nPromises represent the future value of a task. Our app should show a spinner until the gravatar has loaded, but only the first time. Firstly we should refactor our gravatar method to return a promise:\r\n\r\n```objc\r\n- (Promise *)gravatarForEmail:(NSString *)email {\r\n    return [Promise md5:email].then(^(NSString *md5){\r\n        return [NSURLConnection GET:@\"http://gravatar.com/avatar/%@\", md5];\r\n    }).catch(^(NSError *error){\r\n        //TODO\r\n    });\r\n}\r\n\r\n- (void)viewDidLoad {\r\n    // This is a property of type: `Promise *`\r\n    self.gravatarPromise = [self gravatarForEmail:self.email];\r\n    \r\n    self.gravatarPromise.then(^(UIImage *image){\r\n        // Isn’t it nice? Promises are a consistent interface for asyncronicity!\r\n        self.imageView.image = image;\r\n    });\r\n}\r\n```\r\n\r\nWe have to set another `UIImageView` to that gravatar image. Normally you would either load the gravatar again (which is inefficient) or store state about the fact the gravatar is loading and that you should wait, you would then need to react to that state in the final step of your asyncronous-block-tree-of-doom. Promises make it easy:\r\n\r\n```objc\r\n- (void)setThatOtherImageView {\r\n    self.gravatarPromise.then(^(UIImage *img){\r\n        self.otherImageView.image = img;\r\n    });\r\n}\r\n```\r\n\r\nIf a Promise already has a value then the then block is executed immediately. If it is still ***pending*** then the then block is executed once the Promise is ***fulfilled***.\r\n\r\nA key understanding about Promises is that they can exist in two states, *pending* and *fulfilled*. The fulfilled state is either a value or an `NSError` object (Promise values are never `nil`). A Promise can move from pending to fulfilled **exactly once**.\r\n\r\n\r\n#Waiting on Multiple Asyncronous Operations\r\n\r\nOne powerful reason to use asyncronous variants is so we can do two or more asyncronous operations simultaneously. However writing code that acts when the simultaneous operations have all completed is hard. Not so with PromiseKit:\r\n\r\n```objc\r\nid a = [NSURLConnection GET:url1];\r\nid b = [NSURLConnection GET:url2];\r\n[Promise when:@[a, b]].then(^(NSArray *results){\r\n    // do something with both \r\n}).catch(^(NSError *error){\r\n    // with `when`, if any of the Promises fail, the `catch` handler is executed\r\n    NSArray *suberrors = error.userInfo[PMKThrown];\r\n\r\n    // `suberrors` may not just be `NSError` objects, any promises that succeeded\r\n    // have their success values passed to this handler also. Thus you could\r\n    // return a value from this `catch` and have the Promise chain continue, if\r\n    // you don't care about certain errors or can recover.\r\n});\r\n```\r\n\r\n#The Niceties\r\n\r\nPromiseKit aims to provide a category analog for all one-time asyncronous features in the iOS SDK (eg. not for UIButton actions, Promises fulfill ***once*** so some parts of the SDK don’t make sense as Promises—as we currently see it anyway).\r\n\r\nSo far we have:\r\n\r\n```objc\r\n#import \"PromiseKit+Foundation.h\"\r\n\r\n[NSURLConnection GET:[NSURL URLWithString:@\"http://promisekit.org\"]].then(^(NSData *data){\r\n    \r\n}).catch(^(NSError *error){\r\n    NSHTTPURLResponse *rsp = error.userInfo[PMKURLErrorFailingURLResponse];\r\n    int HTTPStatusCode = rsp.statuscode;\r\n});\r\n\r\n// Convenience for the common need to create a URL from a string format:\r\n[NSURLConnection GET:@\"http://google.com/%@\", query].then(…);\r\n\r\n// We’re smart, like AFNetworking\r\n[NSURLConnection GET:@\"http://google.com\" params:@{@\"foo\": @\"bar\"}].then(…);\r\n\r\n// Should you need to customize the HTTP headers, you can do that too:\r\nNSMutableURLRequest *rq = [NSMutableURLRequest new];\r\nrq.setAllHTTPHeaders = self.headers;\r\n[NSURLConnection promise:rq].then(…);\r\n\r\n// PromiseKit reads the response headers and tries to be helpful:\r\n\r\n[NSURLConnection GET:@\"http://placekitten.org/100/100\"].then(^(UIImage *image){\r\n    // Indeed! Pre-converted to a UIImage in a background thread!\r\n});\r\n\r\n[NSURLConnection GET:@\"http://example.com/some.json\"].then(^(NSDictionary *json){\r\n    // Indeed! Pre-deserialized from JSON in a background thread!\r\n});\r\n\r\n// otherwise you get the raw `NSData *`\r\n\r\n\r\n\r\n#import \"PromiseKit+Foundation.h\"\r\n\r\n/**\r\n Sometimes you just want to query the NSURLCache because doing an\r\n NSURLConnection will take too long and just return the same data anyway. We\r\n perform the same header analysis as the NSURLConnection categories, so eg. you\r\n will get back a `UIImage *` or whatever.\r\n**/\r\n[[NSURLCache sharedURLCache] promisedResponseForRequest:rq].then(…)\r\n\r\n\r\n\r\n#import \"PromiseKit+CoreLocation.h\"\r\n\r\n[CLLocationManager promise].then(^(CLLocation *currentUserLocation){\r\n    // If you need the user Location just once, then now you have it\r\n});\r\n\r\n\r\n\r\n#import \"PromiseKit+CommonCrypto.h\"\r\n\r\n[Promise md5:inputString].then(^(NSString *output){\r\n    // MD5 is computed in background thread using CommonCrypto\r\n});\r\n\r\n\r\n\r\n#import \"PromiseKit+UIKit.h\"\r\n\r\nUIAlertView *alert = [[UIAlertView alloc] initWithTitle:@\"You Didn’t Save!\" message: @\"You will lose changes.\" delegate:nil cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"Lose Changes\", @\"Panic\", nil];\r\n\r\nalert.promise.then(^(NSNumber *dismissedIndex){\r\n    // button that wasn’t cancel was pressed\r\n}).catch(^(NSError *error){\r\n    // cancelButton pressed\r\n});\r\n\r\n\r\n#import \"PromiseKit+UIKit.h\"\r\n\r\n/**\r\n We provide a pattern for modally presenting ViewControllers:\r\n**/\r\n\r\n@implementation MyRootViewController\r\n\r\n- (void)foo {\r\n    UIViewController *vc = [MyDetailViewController new];\r\n    [self promiseViewController:vc animated:YES completion:nil].then(^(id result){\r\n        // the result from below in `- (void)someTimeLater`\r\n        // PromiseKit dismisses the MyDetailViewController instance when the\r\n        // Deferred is resolved\r\n    })\r\n}\r\n\r\n@end\r\n\r\n@implementation MyDetailViewController\r\n@property Deferred *deferred;\r\n\r\n- (void)viewWillDefer:(Deferred *)deferMe {\r\n    // Deferred is documented below this section\r\n    _deferred = deferMe;\r\n}\r\n\r\n- (void)someTimeLater {\r\n    [_deferred resolve:someResult];\r\n}\r\n\r\n@end\r\n\r\n```\r\n\r\nNote that simply importing `PromiseKit.h` will import everything.\r\n\r\n\r\n#Deferred\r\n\r\nIf you want to write your own methods that return Promises then often you will need a `Deferred` object. Promises are deliberately opaque; we don’t want other parts of our codebase modifying their values.\r\n\r\nA `Deferred` has a promise, and using a `Deferred` you can set that Promise's value, the Deferred then recursively calls any sub-promises. For example:\r\n\r\n```objc\r\n- (Promise *)tenThousandRandomNumbers {\r\n    Deferred *d = [Deferred new];\r\n\r\n    dispatch_async(q, ^{\r\n        NSMutableArray *numbers = [NSMutableArray new];\r\n        for (int x = 0; x < 10000; x++)\r\n            [numbers addObject:@(arc4random())];\r\n        dispatch)async(dispatch_get_main_queue(), ^{\r\n            if (logic) {\r\n                [d resolve:numbers];\r\n            } else {\r\n                [d reject:[NSError errorWith…]];\r\n            }\r\n        });\r\n    });\r\n\r\n    return d.promise;\r\n}\r\n\r\n- (void)viewDidLoad {\r\n    [self tenThousandRandomNumbers].then(^(NSMutableArray *numbers){\r\n        //…\r\n    });\r\n}\r\n```\r\n\r\n\r\n#The Fine Print\r\n\r\nThe fine print of PromiseKit is mostly exactly what you would expect, so don’t confuse yourself and only come back here when you find yourself curious about more advanced techniques.\r\n\r\n* Returning a Promise as the value of a `then` (or `catch`) handler will cause any subsequent handlers to wait for that Promise to fulfill.\r\n* Returning an instance of `NSError` or throwing an exception within a then block will cause PromiseKit to bubble that object up to the nearest catch handler.\r\n* `catch` handlers always are passed an `NSError` object.\r\n* Returning something other than an `NSError` from a `catch` handler causes PromiseKit to consider the error resolved, and execution will continue at the next `then` handler using the object you returned as the input.\r\n* Not returning from a `catch` handler (or returning nil) causes PromiseKit to consider the Promise complete. No further bubbling occurs.\r\n* Nothing happens if you add a `then` to a failed Promise\r\n* Adding a `catch` handler to a failed Promise will execute that fail handler: this is converse to adding the same to a **pending** Promise.\r\n\r\n\r\n#Caveats\r\n\r\n* We are version 0.9 and thus reserve the right to remove API before 1.0. Probably we won’t, we’re just being cautious.\r\n* PromiseKit is not thread-safe. This is not intentional, we will fix that. Though considering the immutability of Promises, I can’t actually think of an instance where this would be a problem. Really your only concern is to ensure that you return from your `then` handlers in the thread you want subsequent handlers to be run.\r\n\r\n\r\n#TODO\r\n\r\n* Make all categories into optional CocoaPod sub-modules\r\n* Complete categorization of the iOS SDK\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}