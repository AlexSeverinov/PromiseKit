{"name":"Promisekit","tagline":"A delightful Promises implementation for iOS","body":"Modern development is highly asynchronous; isn’t it about time iOS developers had tools that made programming asynchronously powerful, easy and delightful?\r\n\r\nPromiseKit is not just a Promises implementation, it is also a collection of helper functions that make the typical asynchronous patterns we use in iOS development delightful *too*.\r\n\r\nPromiseKit is also designed to be integrated into other CocoaPods. If your library has asyncronous operations and you like PromiseKit, then add an opt-in subspec that provides Promises for your users. HOWTO provided later in this README.\r\n\r\n\r\n#Using PromiseKit\r\n\r\nIn your [Podfile](http://guides.cocoapods.org/using/the-podfile.html):\r\n\r\n```ruby\r\npod 'PromiseKit'\r\n```\r\n\r\nPromiseKit is modulized. If you don’t want any of our category additions:\r\n\r\n```ruby\r\npod 'PromiseKit/base'\r\n```\r\n\r\nOr if you only want some of our categories:\r\n\r\n```ruby\r\npod 'PromiseKit/Foundation'\r\npod 'PromiseKit/UIKit'\r\npod 'PromiseKit/CoreLocation'\r\n```\r\n\r\n\r\n#What is a Promise?\r\n\r\nSynchronous code is clean code. For example, showing a gravatar image:\r\n\r\n```objc\r\nNSString *md5 = md5(email);\r\nNSString *url = [@\"http://gravatar.com/avatar/%@\" stringByAppendingString:md5];\r\nNSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:url]];\r\nself.imageView.image = [UIImage imageWithData:data];\r\n```\r\n\r\nClean but blocking: the UI lags: the user rates you one star.\r\n\r\nThe asynchronous analog suffers from *rightward-drift*:\r\n\r\n\r\n```objc\r\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\r\n    NSString *md5 = md5(email);\r\n    NSString *url = [@\"http://gravatar.com/avatar/%@\" stringByAppendingString:md5];\r\n    NSURLRequest *rq = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];\r\n    [NSURLConnection sendAsynchronousRequest:rq queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {\r\n        UIImage *gravatarImage = [UIImage imageWithData:data];\r\n        dispatch_async(dispatch_get_main_queue(), ^{\r\n            self.imageView.image = gravatarImage;\r\n        });\r\n    }];\r\n});\r\n```\r\n\r\nThe code that does the actual work is now buried inside asynchronicity boilerplate. It is harder to read. The code is less clean.\r\n\r\nPromises are chainable, standardized representations of asynchronous tasks. The equivalent code with PromiseKit looks like:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\ndispatch_promise(^{\r\n    return md5(email);\r\n}).then(^(NSString *md5){\r\n    return [NSURLConnection GET:@\"http://gravatar.com/avatar/%@\", md5];\r\n}).then(^(UIImage *gravatarImage){\r\n    self.imageView.image = gravatarImage;\r\n});\r\n```\r\n\r\nCode with promises is about as close as we can get to clean, synchronous code (at least until Apple give us `@await`…).\r\n\r\n\r\n#Error Handling\r\n\r\nSynchronous code has simple, clean error handling:\r\n\r\n```objc\r\n@try {\r\n    NSString *md5 = md5(email);\r\n    NSString *url = [@\"http://gravatar.com/avatar/%@\" stringByAppendingString:md5];\r\n    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:url]];\r\n    self.imageView.image = [UIImage imageWithData:data];\r\n} @catch (NSError *error) {\r\n    //TODO\r\n}\r\n```\r\n\r\nError handling with asynchronous code is notoriously tricky:\r\n\r\n```objc\r\nvoid (^errorHandler)(NSError *) = ^(NSError *error){\r\n    //TODO\r\n};\r\n\r\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\r\n    @try {\r\n        NSString *md5 = md5(email);\r\n        NSString *url = [@\"http://gravatar.com/avatar/%@\" stringByAppendingString:md5];\r\n        NSURLRequest *rq = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];\r\n        [NSURLConnection sendAsynchronousRequest:rq queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {\r\n\r\n            // the code is now misleading since exceptions thrown in this\r\n            // block will not bubble up to our @catch\r\n\r\n            if (connectionError) {\r\n                errorHandler(connectionError);\r\n            } else {\r\n                UIImage *img = [UIImage imageWithData:data];\r\n                dispatch_async(dispatch_get_main_queue(), ^{\r\n                    self.imageView.image = img;\r\n                });\r\n            }\r\n        }];\r\n    } @catch (NSError *err) {\r\n        errorHandler(err);\r\n    }\r\n});\r\n```\r\n\r\nYuck! Hideous! And *even more* rightward-drift.\r\n\r\nPromises have elegant error handling:\r\n\r\n```objc\r\n#import \"PromiseKit.h\"\r\n\r\ndispatch_promise(^{\r\n    return md5(email);\r\n}).then(^(NSString *md5){\r\n    return [NSURLConnection GET:@\"http://gravatar.com/avatar/%@\", md5];\r\n}).then(^(UIImage *gravatarImage){\r\n    self.imageView.image = gravatarImage;\r\n}).catch(^(NSError *error){\r\n    //TODO\r\n});\r\n```\r\n\r\nErrors bubble up to the first `catch` handler in the chain.\r\n\r\n\r\n#Say Goodbye to Asynchronous State Machines\r\n\r\nPromises represent the future value of a task. You can add more than one `then` handler to a promise. Even after the promise has been fulfilled. If the promise already has a value, the then handler is called immediately:\r\n\r\n```objc\r\n@implementation MyViewController {\r\n    Promise *gravatar;\r\n}\r\n\r\n- (void)viewDidLoad {\r\n    gravatar = dispatch_promise(^{\r\n        return md5(email);\r\n    }).then(^(NSString *md5){\r\n        return [NSURLConnection GET:@\"http://gravatar.com/avatar/%@\", md5];\r\n    });\r\n\r\n    gravatar.then(^(UIImage *image){\r\n        self.imageView.image = image;\r\n    });\r\n}\r\n\r\n- (void)someTimeLater {\r\n    gravatar.then(^(UIImage *image){\r\n        // likely called immediately, but maybe not. We don’t have to worry!\r\n        self.otherImageView.image = image;\r\n    });\r\n}\r\n\r\n@end\r\n```\r\n\r\nA key understanding is that Promises can only exist in two states, *pending* or *fulfilled*. The fulfilled state is either a value or an `NSError` object. A Promise can move from pending to fulfilled **exactly once**.\r\n\r\n\r\n#Waiting on Multiple Asynchronous Operations\r\n\r\nOne powerful reason to use asynchronous variants is so we can do two or more asynchronous operations simultaneously. However writing code that acts when the simultaneous operations have all completed is hard. Not so with PromiseKit:\r\n\r\n```objc\r\nid a = [NSURLConnection GET:url1];\r\nid b = [NSURLConnection GET:url2];\r\n\r\n[Promise when:@[a, b]].then(^(NSArray *results){\r\n    // results[0] is the result from a\r\n    // results[1] is the result from b\r\n}).catch(^(NSError *error){\r\n    // with `when`, if any of the Promises fail, the `catch` handler is executed\r\n    NSArray *suberrors = error.userInfo[PMKThrown];\r\n\r\n    // `suberrors` may not just be `NSError` objects, any promises that succeeded\r\n    // have their success values passed to this handler also. Thus you could\r\n    // return a value from this `catch` and have the Promise chain continue, if\r\n    // you don't care about certain errors or can recover.\r\n});\r\n```\r\n\r\n\r\n#Forgiving Syntax\r\n\r\nIn case you didn't notice, the block you pass to `then` or `catch` can have return type of `Promise`, or any object, or nothing. And it can have a parameter of `id`, or a specific class type, or nothing.\r\n\r\nThis is not usual to Objective-C or blocks. Usually everything is very explicit. We are using introspection to determine what arguments and return types you are working with. Thus, programming with PromiseKit has similarities to programming with more modern languages like Ruby or Javascript.\r\n\r\n\r\n#The Niceties\r\n\r\nPromiseKit aims to provide a category analog for all one-time asynchronous features in the iOS SDK (eg. not for UIButton actions, Promises fulfill ***once*** so some parts of the SDK don’t make sense as Promises).\r\n\r\nAn additional important consideration is that we only trigger the catch handler for errors. Thus UIAlertView does not trigger the catch handler for cancel button pushes. Initially we had it that way, and it led to error handling code that was messy and unreliable. The error path is **only** for errors.\r\n\r\n##NSURLConnection+PromiseKit\r\n\r\n```objc\r\n#import \"PromiseKit+Foundation.h\"\r\n\r\n[NSURLConnection GET:@\"http://promisekit.org\"].then(^(NSData *data){\r\n    \r\n}).catch(^(NSError *error){\r\n    NSHTTPURLResponse *rsp = error.userInfo[PMKURLErrorFailingURLResponse];\r\n    int HTTPStatusCode = rsp.statuscode;\r\n});\r\n```\r\n\r\nAnd a convenience string format variant:\r\n\r\n```objc\r\n[NSURLConnection GET:@\"http://example.com/%@\", folder].then(^{\r\n    //…\r\n});\r\n```\r\n\r\nAnd a variant that constructs a correctly URL encoded query string from a dictionary:\r\n\r\n```objc\r\n[NSURLConnection GET:@\"http://example.com\" query:@{@\"foo\": @\"bar\"}].then(^{\r\n    //…\r\n});\r\n```\r\n\r\nAnd a POST variant:\r\n\r\n```objc\r\n[NSURLConnection POST:@\"http://example.com\" formURLEncodedParameters:@{@\"key\": @\"value\"}].then(^{\r\n    //…\r\n});\r\n```\r\n\r\nPromiseKit reads the response headers and tries to be helpful:\r\n\r\n```objc\r\n[NSURLConnection GET:@\"http://example.com/some.json\"].then(^(NSDictionary *json){\r\n    if ([json isKindOfClass:[NSDictionary class]]) {\r\n        NSLog(@\"Yes! Indeed, we converted the JSON data into an NSDictionary for you!\");\r\n    }\r\n});\r\n\r\n[NSURLConnection GET:@\"http://placekitten.org/100/100\"].then(^(UIImage *image){\r\n    if ([image isKindOfClass:[UIImage class]]) {\r\n        NSLog(@\"Yes! Indeed, we converted the data into a UIImage for you!\");\r\n    }\r\n});\r\n```\r\n\r\nOtherwise we return the raw `NSData`.\r\n\r\n\r\n##NSURLCache+PromiseKit\r\n\r\nSometimes you just want to query the `NSURLCache` because doing an `NSURLConnection` will take too long and just return the same data anyway. We perform the same header analysis as the `NSURLConnection` categories, so eg. you will get back a `UIImage *` or whatever. If there is nothing in the cache, then you get back `nil`.\r\n\r\n```objc\r\n#import \"PromiseKit+Foundation.h\"\r\n\r\n[[NSURLCache sharedURLCache] promisedResponseForRequest:rq].then(^(id o){\r\n    return o ?: [NSURLConnection GET:rq];\r\n});\r\n```\r\n\r\n\r\n##CLLocationManager+PromiseKit\r\n\r\nA promise for a one time update of the user’s location:\r\n\r\n```objc\r\n#import \"PromiseKit+CoreLocation.h\"\r\n\r\n[CLLocationManager promise].then(^(CLLocation *currentUserLocation){\r\n});\r\n```\r\n\r\n\r\n##UIAlertView+PromiseKit\r\n\r\nA promise for showing a `UIAlertView`:\r\n\r\n```objc\r\n#import \"PromiseKit+UIKit.h\"\r\n\r\nUIAlertView *alert = [[UIAlertView alloc] initWithTitle:@\"You Didn’t Save!\"\r\n                      message:@\"You will lose changes.\"\r\n                     delegate:nil\r\n            cancelButtonTitle:@\"Cancel\"\r\n            otherButtonTitles:@\"Lose Changes\", @\"Panic\", nil];\r\n\r\nalert.promise.then(^(NSNumber *dismissedIndex){\r\n    //…\r\n});\r\n```\r\n\r\n\r\n##UIActionSheet+PromiseKit\r\n\r\nSame pattern as for `UIAlertView`.\r\n\r\n\r\n##UIViewController+PromiseKit\r\n\r\nWe provide a pattern for modally presenting ViewControllers and getting back a result:\r\n\r\n```objc\r\n#import \"PromiseKit+UIKit.h\"\r\n\r\n@implementation MyRootViewController\r\n\r\n- (void)foo {\r\n    UIViewController *vc = [MyDetailViewController new];\r\n    [self promiseViewController:vc animated:YES completion:nil].then(^(id result){\r\n        // the result from below in `someTimeLater`\r\n        // PromiseKit dismisses the MyDetailViewController instance when the\r\n        // Deferred is resolved\r\n    });\r\n}\r\n\r\n@end\r\n\r\n@implementation MyDetailViewController\r\n@property Deferred *deferred;\r\n\r\n- (void)viewWillDefer:(Deferred *)deferMe {\r\n    // Deferred is documented below this section\r\n    _deferred = deferMe;\r\n}\r\n\r\n- (void)someTimeLater {\r\n    [_deferred resolve:someResult];\r\n}\r\n\r\n@end\r\n```\r\n\r\nAs a bonus we handle some of the tedious special ViewController types for you so you don't have to delegate. Currently just `MFMailComposeViewController`. So you can `then` off of it without having to write any delegate code:\r\n\r\n```objc\r\nid mailer = [MFMailComposerViewController new];\r\n[self promiseViewController:mailer animated:YES completion:nil].then(^(NSNumber  *num){\r\n    // num is the result passed from the MFMailComposeViewControllerDelegate\r\n}).catch(^{\r\n    // the error from the delegate if that happened\r\n})\r\n```\r\n\r\nNote that simply importing `PromiseKit.h` will import everything.\r\n\r\n\r\n#Promise Factories\r\n\r\nWith the next version of Promise Kit we plan to add a Promise-Factory type feature so we can have promises generated from `NSNotificationCenter` and `UIControl`s and that sort of thing. It doesn't make sense to have plain promises because Promises can only be fulfilled once.\r\n\r\nPromiseKit aims to be a complete and delightful addition to your toolkit.\r\n\r\n\r\n#Deferred\r\n\r\nIf you want to write your own methods that return Promises then often you will need a `Deferred` object. Promises are deliberately opaque: you can't directly modify them, only their parent promise can.\r\n\r\nA `Deferred` has a promise, and using a `Deferred` you can set that Promise's value, the Deferred then recursively calls any sub-promises. For example:\r\n\r\n```objc\r\n- (Promise *)tenThousandRandomNumbers {\r\n    Deferred *d = [Deferred new];\r\n\r\n    dispatch_async(q, ^{\r\n        NSMutableArray *numbers = [NSMutableArray new];\r\n        for (int x = 0; x < 10000; x++)\r\n            [numbers addObject:@(arc4random())];\r\n        dispatch_async(dispatch_get_main_queue(), ^{\r\n            if (logic) {\r\n                [d resolve:numbers];\r\n            } else {\r\n                [d reject:[NSError errorWith…]];\r\n            }\r\n        });\r\n    });\r\n\r\n    return d.promise;\r\n}\r\n\r\n- (void)viewDidLoad {\r\n    [self tenThousandRandomNumbers].then(^(NSMutableArray *numbers){\r\n        //…\r\n    });\r\n}\r\n```\r\n\r\nAlthough for the common case of an operation that runs in the background we offer the convenience function `dispatch_promise`, which is like `dispatch_async`, but returns a Promise (which continues on the main queue). So the above would be:\r\n\r\n```objc\r\n- (Promise *)tenThousandRandomNumbers {\r\n    return dispatch_promise(^{\r\n        NSMutableArray *numbers = [NSMutableArray new];\r\n        for (int x = 0; x < 10000; x++)\r\n            [numbers addObject:@(arc4random())];\r\n        return numbers;\r\n    });\r\n}\r\n```\r\n\r\n`dispatch_promise` runs on `DISPATCH_QUEUE_PRIORITY_DEFAULT`. If you want other queue priorities then write your own dispatch wrapper around a `Deferred`.\r\n\r\n\r\n#The Fine Print\r\n\r\nThe fine print of PromiseKit is mostly exactly what you would expect, so don’t confuse yourself and only come back here when you find yourself curious about more advanced techniques.\r\n\r\n* Returning a Promise as the value of a `then` (or `catch`) handler will cause any subsequent handlers to wait for that Promise to fulfill.\r\n* Returning an instance of `NSError` or throwing an exception within a then block will cause PromiseKit to bubble that object up to the nearest catch handler.\r\n* `catch` handlers always are passed an `NSError` object.\r\n* Returning something other than an `NSError` from a `catch` handler causes PromiseKit to consider the error resolved, and execution will continue at the next `then` handler using the object you returned as the input.\r\n* Not returning from a `catch` handler (or returning nil) causes PromiseKit to consider the Promise complete. No further bubbling occurs.\r\n* Nothing happens if you add a `then` to a failed Promise\r\n* Adding a `catch` handler to a failed Promise will execute that fail handler: this is converse to adding the same to a **pending** Promise.\r\n\r\n\r\n#Adding Promises to Third Party Libraries\r\n\r\nIt would be great if every library with asynchronous functionality would offer opt-in `Promise *` variants for the asynchronous mechanisms.\r\n\r\nShould you want to add PromiseKit integration to your library, the general premise is to add an opt-in `subspec` to your `podspec` that provides methods that return `Promise`s. For example if we imagine a library that overlays a kitten on an image:\r\n\r\n```objc\r\n@interface ABCKitten\r\n- (instancetype)initWithImage:(UIImage *)image;\r\n- (void)overlayKittenWithCompletionBlock:(void)(^)(UIImage *, NSError *))completionBlock;\r\n@end\r\n```\r\n\r\nOpt-in PromiseKit support would include a new file `ABCKitten+PromiseKit.h`:\r\n\r\n```objc\r\n#import <PromiseKit/Promise.h>\r\n#import \"ABCKitten.h\"\r\n\r\n\r\n@interface ABCKitten (PromiseKit)\r\n\r\n/**\r\n * Returns a Promise that overlays a kitten image.\r\n * @return A Promise that will then a `UIImage *` object.\r\n */\r\n- (Promise *)overlayKitten;\r\n\r\n@end\r\n```\r\n\r\nIt's crucially important to document your Promise methods [properly](http://nshipster.com/documentation/), because the result of a Promise can be any object type and your users need to be able to easily look up the types by ⌥ clicking the method.\r\n\r\nConsumers of your library would then include in their `Podfile`:\r\n\r\n```ruby\r\npod 'ABCKitten/PromiseKit'\r\n```\r\n\r\nThis is the “opt-in” step.\r\n\r\nFinally you need to modify your `podspec`. If it was something like this:\r\n\r\n```ruby\r\nPod::Spec.new do |s|\r\n  s.name         = \"ABCKitten\"\r\n  s.version      = \"1.1\"\r\n  s.source_files = 'ABCKitten.{m,h}'\r\nend\r\n```\r\n\r\nThen you would need to convert it to the following:\r\n\r\n```ruby\r\nPod::Spec.new do |s|\r\n  s.name         = \"ABCKitten\"\r\n  s.version      = \"1.1\"\r\n\r\n  s.default_subspec = 'base'\r\n\r\n  s.subspec 'base' do |ss|\r\n    ss.source_files = 'ABCKitten.{m,h}'\r\n  end\r\n\r\n  s.subspec 'PromiseKit' do |ss|\r\n    ss.dependency 'PromiseKit/base', 'ABCKitten/base'\r\n    ss.source_files = 'ABCKitten+PromiseKit.{m,h}'\r\n  end\r\nend\r\n```\r\n\r\nAs a further example, the actual implementation of `- (Promise *)overlayKitten` would likely be as simple as this:\r\n\r\n```objc\r\n- (Promise *)overlayKitten {\r\n    Deferred *deferred = [Deferred new];\r\n    [self overlayKittenWithCompletionBlock:^(UIImage *img, NSError *err){\r\n        if (err)\r\n            [deferred reject:err];\r\n        else\r\n            [deferred resolve:img];\r\n    }];\r\n    return deferred.promise;\r\n}\r\n```\r\n\r\n\r\n#Adding PromiseKit to Someone Else’s Pod\r\n\r\nFirstly you should try submitting the above to the project itself. If they won’t add it then you'll need to make your own pod. Use the naming scheme: `ABCKitten+PromiseKit`.\r\n\r\n\r\n#Caveats\r\n\r\n* We are version 0.9 and thus reserve the right to remove API before 1.0. Probably we won’t, we’re just being cautious.\r\n* PromiseKit is not thread-safe. This is not intentional, we will fix that. Though in general use it isn't common to compromise the thread-safety of PromiseKit. So just ensure you are happy with the thread any Deferreds are resolved upon.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}